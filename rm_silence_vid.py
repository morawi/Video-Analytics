#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Feb 10 17:51:52 2019

@author: Mohammed Al-Rawi

Removing silence segements from videos. 
Noise value can be used to control how much noise needs to be remvoed. Lower 
'noise' dB value indicates lower noise (keeping in mind that -90 is lower than -30).

"""

import multiprocessing
import time
import argparse
import subprocess
import os
import re
import tqdm

parser = argparse.ArgumentParser()
parser.add_argument('--video_in', type=str, default='Pacino.mp4', help='Name of input video file')
parser.add_argument('--video_out', type=str, default='Pacino_no_silence.mp4', 
                    help='Name of output video file such that silence removed')
parser.add_argument('--silecne_file_out', type=str, default='tag_silence.txt', 
                    help='Temporary text file that stores the detected silence,  this is not needed by the user, and can be removed')
parser.add_argument('--noise', type=int, default=-30, help=
                    '-10<noise<-90: Low value removes a lot of noise in dB, higher values are some how tollerant')
param = parser.parse_args()

           
''' This function generates the progress bar in parallel with the other function
that removes the silence, which is called process_movie. The function is simple, it reads the size of
generated (no silence) video file every 3 seconds and updates the progress bar, until the size stops 
increaseing which mimics the end of finish, i.e. "silence removal". This function can be imporoved in many ways, 
like for example, doing some analysis on the size of input file and finding the correlation between the size
help estimating the size of the output (no silence file) and a better progress bar would be feasible. '''  
def progress_bar(param):
    size_in = 10*int( os.stat(param.video_in).st_size /1000000) # size of input file
    size_out = 1;  size_old = 0   
    time.sleep(3) # waiting for a while until silence tagging is done        
    pbar = tqdm.tqdm(total = 100)   # the progress bar has 100 bins
    while True:
        if os.path.exists(param.video_out):                             
            size_out = 10*int ( os.stat(param.video_out).st_size/1000000)              
            if size_out == size_old: # when the size is not changngeing, silence removal is done
                return            
            else: 
                size_old = size_out            
        else:
            size_out=0                  
        pbar.update(int(.25* (100*size_out)/size_in))        
        time.sleep(3)    
              
'''This is the core function that useses ffmpeg to detect the silence intervals,
then, remoging it, again, wiht ffmpeg. We are using a subproecess that calls ffmpeg 
from the command line. '''
def process_movie(param):         
    if os.path.exists(param.video_out):
        print('Removing old %s file' % param.video_out)
        subprocess.call('rm -f '+ param.video_out, shell=True) 
    print('Detecting silence intervals, and then, removing the detected silence')
    cmd_dtct_silence = 'ffmpeg -i '+ param.video_in +  ' -af silencedetect=noise='+str(param.noise)+'dB:d=0.5 -f null - 2> ' + param.silecne_file_out
    x1 = subprocess.call(cmd_dtct_silence, shell=True)
    if x1!=0: print('Silense taggin not successful')
    start_time, end_time = get_times(param.silecne_file_out)
    cmd_rmv_silence = time_to_cmd(start_time, end_time, param)          
    x2 = subprocess.call(cmd_rmv_silence, shell=True)
    if x2!=0: print('Silence removal not successful')
    

''''This function converst  H:M:S time into seconds '''
def hms_time_to_sec(time_str):
    h_m_s = time_str.split(':')
    return float(h_m_s[0]) * 3600 + float(h_m_s[1]) * 60 + float(h_m_s[2])

'''This function reads the file generated by ffmpeg silence detection. 
The file is genrated after running the command "cmd_dtct_silence" 
shown in process_movie() function. This function can be improved in many ways. '''
def get_times(fname):
    text_file = open(fname, "r")
    text_lines = text_file.readlines()
    start_time =[]
    end_time = []
    movie_duration = 0 # forward assignment to prevent warnings
    for line in text_lines:        
        if  re.search(r'\b(Duration)\b', line) !=None: 
            token = line.split()
            movie_duration = token[1]    # read movie duration
        if re.search(r'\b(silencedetect)\b', line) !=None:
            token = line.split()
            if token[3] == 'silence_start:':
                start_time.append(abs(float(token[4]))) # for some reason, start time is -0.01
                # start_time.append(float(token[4])) # for some reason, start time is -0.01
            elif token[3] ==  'silence_end:':
                end_time.append(float(token[4]))
            else:
                continue
    end_time.insert(0, 0) # For pos 0, insert time 0; see Timing Algorithm used in time_to_cmd()
    movie_duration = hms_time_to_sec(movie_duration[:-1])
    start_time.append(movie_duration)
    end_time.append(movie_duration) if len(end_time)<len(start_time) else None # sometimes silence is detected, but ends with the movie, so, we might not have end_time for the last detected silence, we need thus to add/append the end of the movie 
    
    return start_time, end_time

'''This function converts the detected silence times, that are obtained via
get_times() function into a command that can be used to remove the silce by ffmpeg '''
def time_to_cmd(start_time, end_time, param):
    ''' Timing Algorithm used:
    
    t0(inserted to end_time)->tstrt1
    tend1->tstrt2
    .
    .
    tend_m -> t_movie_duration(appended to start_time)    
'''

    strt_end_string =''
    for i in range(len(start_time)):    
        strt_end_string = strt_end_string + \
        'between(t,' + str(end_time[i]) + ',' + str(start_time[i])+')' + '+'
    strt_end_string = strt_end_string[:-1] # removing last plus
    
    cmd_rmv_silence = 'ffmpeg -loglevel quiet -i '+ param.video_in + ' -vf ' 
    cmd_rmv_silence = cmd_rmv_silence + '"select=' "'" + strt_end_string + "'" 
    cmd_rmv_silence = cmd_rmv_silence + ', setpts=N/FRAME_RATE/TB"'
    cmd_rmv_silence = cmd_rmv_silence + ' -af ' 
    cmd_rmv_silence = cmd_rmv_silence + '"aselect=' "'" + strt_end_string + "'"  
    cmd_rmv_silence = cmd_rmv_silence + ',asetpts=N/SR/TB" ' +  param.video_out

    return cmd_rmv_silence
    

# if __name__ == '__main__':   
if not os.path.exists(param.video_in):    
      print('Cannot open file', param.video_in)
      exit(0)
else: 
    '''Here, we have two parallel processes, p1 that processes the movie
    and p2 that generates a progress bar. This is because I am using ffmpeg
    from the terminal/shell to detect the silence, and then, to remove it.'''
    p1 = multiprocessing.Process(target=process_movie, args = (param,))  
    p1.start()
    p2 = multiprocessing.Process(target=progress_bar, args=(param,))
    p2.start()    


   
        
    




        
        

    


